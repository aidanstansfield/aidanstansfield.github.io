<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>The Raspberry Pi Project: Part 2 - Web Server | Aidan&#39;s Blog</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="The Raspberry Pi Project: Part 2 - Web Server" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="So as I mentioned in my previous post, I wanted to use my Raspberry Pi as a webserver so that I could play around with web development projects. More specifically, I wanted to run NGINX, with autogenerated SSL certs from Let&#39;s Encrypt, and I wanted a Dynamic DNS address so that I didn&#39;t have to deal with changing IP addresses provided by my ISP. Oh, and I wanted this to all be described by one simple docker-compose.yml file." />
<meta property="og:description" content="So as I mentioned in my previous post, I wanted to use my Raspberry Pi as a webserver so that I could play around with web development projects. More specifically, I wanted to run NGINX, with autogenerated SSL certs from Let&#39;s Encrypt, and I wanted a Dynamic DNS address so that I didn&#39;t have to deal with changing IP addresses provided by my ISP. Oh, and I wanted this to all be described by one simple docker-compose.yml file." />
<link rel="canonical" href="https://aidanstansfield.github.io/2020/03/15/raspi-p2.html" />
<meta property="og:url" content="https://aidanstansfield.github.io/2020/03/15/raspi-p2.html" />
<meta property="og:site_name" content="Aidan&#39;s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-15T16:25:00+10:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://aidanstansfield.github.io/2020/03/15/raspi-p2.html"},"@type":"BlogPosting","url":"https://aidanstansfield.github.io/2020/03/15/raspi-p2.html","headline":"The Raspberry Pi Project: Part 2 - Web Server","dateModified":"2020-03-15T16:25:00+10:00","datePublished":"2020-03-15T16:25:00+10:00","description":"So as I mentioned in my previous post, I wanted to use my Raspberry Pi as a webserver so that I could play around with web development projects. More specifically, I wanted to run NGINX, with autogenerated SSL certs from Let&#39;s Encrypt, and I wanted a Dynamic DNS address so that I didn&#39;t have to deal with changing IP addresses provided by my ISP. Oh, and I wanted this to all be described by one simple docker-compose.yml file.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
  <link rel="icon" type="image/png" href="/assets/favicon.png" /><link type="application/atom+xml" rel="alternate" href="https://aidanstansfield.github.io/feed.xml" title="Aidan's Blog" /></head>
<body><div class="site-header">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Aidan&#39;s Blog<b class="command_prompt"></b><b class="blinking_cursor">_</b></a>
    <span class="social_links">
        <a class="color-green-hover" href="https://www.hackthebox.eu/profile/119119"><i class="fal fa-cube"></i></a><a class="color-orange-hover" href="https://github.com/aidanstansfield"><i class="fab fa-github"></i></a><a class="color-cyan-hover" href="https://linkedin.com/in/aidanstansfield"><i class="fab fa-linkedin-in"></i></a>
    </span>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
  <div class="author-box">

<img src="https://gravatar.com/avatar/47d8936d80a1b1c3b637741f001626a2?s=256" class="author-avatar" />

G'day, I'm Aidan and I like to make things, almost as much as I like to break things. In this blog you can expect to find writeups of various home/personal projects, as well as hackthebox/ctf writeups. Hope you enjoy!
</div>


<div class="post">
  <h1 class="post-title">The Raspberry Pi Project: Part 2 - Web Server</h1>
  
  <div class="post-date">Published on 15 Mar 2020</div>
  
  <p>So as I mentioned in my <a href="/2020/03/14/raspi-p1.html">previous post</a>, I wanted to use my Raspberry Pi as a webserver so that I could play around with web development projects. More specifically, I wanted to run NGINX, with autogenerated SSL certs from Let's Encrypt, and I wanted a Dynamic DNS address so that I didn't have to deal with changing IP addresses provided by my ISP. Oh, and I wanted this to all be described by one simple <code>docker-compose.yml</code> file.</p>
<h2 id="installing-prerequisites">Installing Prerequisites</h2>
<p>First things first, you'll need to get a Raspberry Pi up and running with Raspbian. There's plenty of guides on this so if you have know idea, do some googling.</p>
<p>Next, we need to install Docker &amp; Docker Compose. We'll start with Docker.</p>
<pre><code>curl -fsSL get.docker.com -o get-docker.sh &amp;&amp; sh get-docker.sh
</code></pre>
<p>Next, I'd recommend adding yourself to the Docker group so that you don't have to use <code>sudo</code> every time you want to run a Docker command.</p>
<pre><code>sudo usermod -aG docker pi
</code></pre>
<p>Next, update your packages.</p>
<pre><code>sudo apt update &amp;&amp; sudo apt upgrade
</code></pre>
<p>Now we shall enable the Docker service so that it automatically starts up on boot.</p>
<pre><code>sudo systemctl enable docker
</code></pre>
<p>Last but not least, let's install docker-compose</p>
<pre><code>sudo apt install docker-compose
</code></pre>
<p>T
o make sure everything is working properly, let's run the infamous <code>hello-world</code> container!</p>
<pre><code>docker run hello-world
</code></pre>
<p>You should see Docker look for the <code>hello-world</code> container locally, fail to find it, pull it from the Docker Registry, run it and then display the result in the terminal! If you see this, your Docker installation is working!</p>
<h2 id="docker-amp-docker-compose">Docker &amp; Docker Compose</h2>
<p>So what is Docker? Well, I won't regurgitate what 1000 other blogs have already explained far better than I ever could, so instead, here's the TLDR:</p>
<blockquote>
<p>Docker lets you package apps and all their dependencies into 'containers' that can be downloaded and run on any platform that supports Docker.</p>
</blockquote>
<p>Docker Compose?</p>
<blockquote>
<p>Docker compose lets you write down how to run a container(s), so that you don't have to write it all out in the command line every time you wanna boot it up.</p>
</blockquote>
<p>It's more complicated than that, but if you want to find out more, I won't stop you.</p>
<p>So rather then explain how Docker Compose files work in general, I figured I'd walk you through my <code>docker-compose.yml</code> file, because I learn best from examples!</p>
<h2 id="duckdns">DuckDNS</h2>
<p>So here is a snippet of my compose file that I use to build my web server. This part in particular is used to run my DuckDNS client, so that my dynamic DNS address will always stay up to date. It's a fairly straight forward example, so let's take a look.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">duckdns</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">linuxserver/duckdns:arm32v7-latest</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">duckdns</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">TZ</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Australia/Brisbane"</span>
      <span class="na">TOKEN</span><span class="pi">:</span> <span class="s2">"</span><span class="s">${DUCKDNS_TOKEN}"</span>
      <span class="na">SUBDOMAINS</span><span class="pi">:</span> <span class="s1">'</span><span class="s">deluqs'</span>
      <span class="na">PUID</span><span class="pi">:</span> <span class="m">1000</span>
      <span class="na">GUID</span><span class="pi">:</span> <span class="m">1000</span>
      <span class="na">LOG_FILE</span><span class="pi">:</span> <span class="s1">'</span><span class="s">true'</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s1">'</span><span class="s">./duckdns/config:/config'</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
</code></pre></div></div>
<p>To start with, I declare which version of docker-compose I am using. At the time of writing, 3 is the latest, so that is what I am using. Next I declare the services I want to run, which in this case, is just one service I've called 'duckdns'.</p>
<p>I then tell Docker to use the 'linuxserver/duckdns:arm32v7-latest' image, which just describes which container I want to run. More specifically, look for the 'duckdns' image by the Docker Hub account 'linuxserver', with the tag 'arm32v7-latest'. Note that it is important to declare the use of the 'arm32v7-latest' tag, since the Raspberry Pi 4 runs on arm32v7 architecture. Remember this, because I will bring it up again later.</p>
<p>Next I give the container the name 'duckdns', as well as a bunch of environment variables. To see the explanation behind each of these environment variables, see the <a href="https://hub.docker.com/r/linuxserver/duckdns/">linuxserver/duckdns documentation</a>. It is also worth noting that in the same directory as the <code>docker-compose.yml</code> file, I have a .env file that contains my <code>DUCKDNS_TOKEN</code>, which will get substituted in at runtime.</p>
<p>Next, I tell Docker to mount the <code>/config</code> folder within the duckdns container to the folder <code>./duckdns/config</code> on my Pi. This allows me to easily see the duck.log file from the host, as it gets written to <code>/config/duck.log</code> within the container.</p>
<p>Finally, I make sure that the container always restarts, unless I've manually stopped it. This makes sure that it will automatically start on boot.</p>
<h2 id="nginx">NGINX</h2>
<p>Next, the container I use to run NGINX.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">duckdns</span><span class="pi">:</span>
    <span class="s">...</span>
  <span class="na">nginx-proxy</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">aidanstansfield/nginx-proxy:arm32v7</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">nginx-proxy</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">80:80</span>
      <span class="pi">-</span> <span class="s">443:443</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/var/run/docker.sock:/tmp/docker.sock:ro</span>
      <span class="pi">-</span> <span class="s">certs:/etc/nginx/certs:ro</span>
      <span class="pi">-</span> <span class="s">vhost:/etc/nginx/vhost.d</span>
      <span class="pi">-</span> <span class="s">html:/usr/share/nginx/html</span>
      <span class="pi">-</span> <span class="s">conf:/etc/nginx/conf.d</span>
      <span class="pi">-</span> <span class="s">dhparam:/etc/nginx/dhparam</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">DEFAULT_HOST</span><span class="pi">:</span> <span class="s2">"</span><span class="s">deluqs.duckdns.org"</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">conf</span><span class="pi">:</span>
  <span class="na">vhost</span><span class="pi">:</span>
  <span class="na">html</span><span class="pi">:</span>
  <span class="na">dhparam</span><span class="pi">:</span>
  <span class="na">certs</span><span class="pi">:</span>
</code></pre></div></div>
<p>Now, there's a couple of differences between this and the DuckDNS example above. The most obvious one, is that it's a different image (duh). The <a href="https://github.com/aidanstansfield/nginx-proxy">image</a> I'm using is a customized version of <a href="https://github.com/nginx-proxy/nginx-proxy">jwilder's nginx-proxy</a> that I built myself, with support for the arm32v7 architecture.</p>
<p><em>NOTE: I plan on doing a blog post on why and how I built this container in the future, so keep your eyes peeled!</em></p>
<p>If you aren't familiar with <a href="https://github.com/nginx-proxy/nginx-proxy">jwilder's nginx-proxy</a>, what it does is observe the Docker containers you run, and if any have the environment variable <code>VIRTUAL_HOST</code>, it will automagically setup an NGINX proxy and point it to that container!</p>
<p>For instance, say I spin up a container of some kind that serves web content out of port 80. If I add the environment variable <code>VIRTUAL_HOST: &quot;deluqs.duckdns.org&quot;</code> to that service, then NGINX will see that and setup the necessary config files to proxy any requests for the host &quot;deluqs.duckdns.org&quot; to port 80 within that container. See the pieces starting to come together?</p>
<p>The next difference with the <code>docker-compose.yml</code> is that I've declared some port bindings. These simply mean <code>listen to this port on the host:pass it to this port in the container</code>. So any traffic that hits port 80 on my Pi will be forwarded to the nginx-proxy container's port 80.</p>
<p>The final difference is the volumes! Notably, you will see that I've mounted a special <code>/var/run/docker.sock:/tmp/docker.sock:ro</code> volume, as well as some other named volumes like <code>html:/usr/share/nginx/html</code>. The first volume is special as it allows communication between the container and the docker daemon running on the host, and the <code>:ro</code> specifies it is read-only.</p>
<p>The named volume is similar to the ones we described earlier, but we're letting docker decide where to store the volume on the host, and we're giving it a name so that we may reference it later as you shall soon see. Note that named volumes need to be declared at the global level, as seen at the bottom of the compose file.</p>
<h2 id="lets-encrypt">Let's Encrypt</h2>
<p>Finally, the magic that turns SSL on for all nginx-proxy sites.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">duckdns</span><span class="pi">:</span>
    <span class="s">...</span>
  <span class="na">nginx-proxy</span><span class="pi">:</span>
    <span class="s">...</span>
  <span class="na">letsencrypt-nginx-proxy-companion</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">aidanstansfield/docker-letsencrypt-nginx-proxy-companion:arm32v7</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">le-nginx-proxy-companion</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">/var/run/docker.sock:/var/run/docker.sock:ro</span>
      <span class="pi">-</span> <span class="s">certs:/etc/nginx/certs:rw</span>
      <span class="pi">-</span> <span class="s">vhost:/etc/nginx/vhost.d</span>
      <span class="pi">-</span> <span class="s">html:/usr/share/nginx/html</span>
      <span class="pi">-</span> <span class="s">conf:/etc/nginx/conf.d</span>
      <span class="pi">-</span> <span class="s">dhparam:/etc/nginx/dhparam</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">DEFAULT_EMAIL</span><span class="pi">:</span> <span class="s2">"</span><span class="s">aidan.stansfield@gmail.com"</span>
      <span class="na">NGINX_PROXY_CONTAINER</span><span class="pi">:</span> <span class="s2">"</span><span class="s">nginx-proxy"</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">conf</span><span class="pi">:</span>
  <span class="na">vhost</span><span class="pi">:</span>
  <span class="na">html</span><span class="pi">:</span>
  <span class="na">dhparam</span><span class="pi">:</span>
  <span class="na">certs</span><span class="pi">:</span>
</code></pre></div></div>
<p>This has nothing you haven't seen before, but I'm including it for completeness sake. You'll notice that again, I'm using an <a href="https://github.com/aidanstansfield/docker-letsencrypt-nginx-proxy-companion">image</a> that I have built myself, based upon <a href="https://github.com/nginx-proxy/docker-letsencrypt-nginx-proxy-companion">jrcs' docker-letsencrypt-nginx-proxy-companion</a>, so that it supports the arm32v7 architecture.</p>
<p>Notice that we're using the same named volumes as the nginx-proxy service, and that allows these two seperate services to both access the same files.</p>
<h1 id="summary">Summary</h1>
<p>So that's how I run my DuckDNS, NGINX and Let's Encrypt services on my Raspberry Pi with just a single <code>docker-compose up</code>. Note that I never have to touch NGINX config files, or deal with setting up SSL, all I need to do is pass in an environment variable or two into any container I spin up and it's all handled for me, <strong>how neat.</strong> Hope you found some of this useful!</p>

</div>


<div class="comments">
<div id="disqus_thread"></div>
<script>
 var disqus_config = function () {
     this.page.url = 'https://aidanstansfield.github.io/2020/03/15/raspi-p2.html';
     this.page.identifier = '/2020/03/15/raspi-p2';
     this.page.title = 'The Raspberry Pi Project: Part 2 - Web Server';
 };

 (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
     var d = document, s = d.createElement('script');

     s.src = '//aidan.disqus.com/embed.js';

     s.setAttribute('data-timestamp', +new Date());
     (d.head || d.body).appendChild(s);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

</div>




<div class="related">
  <h2>related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2020/04/26/intro-to-websec.html">
            Intro to Web Security
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/03/30/htb-registry-walkthrough.html">
            Registry: Hack The Box Writeup
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2020/03/14/raspi-p1.html">
            The Raspberry Pi Project: Part 1 - The Context
          </a>
        </h3>
      </li>
    
  </ul>
</div>





      </div>
    </main><footer class="site-footer">
  <div class="wrapper">
    <div class="credits"><a href="https://github.com/bitbrain/jekyll-dash">dash</a> theme for Jekyll by <a href="https://github.com/bitbrain">bitbrain</a> made with <i class="fas fa-heart"></i><div class="toggleWrapper">
    <input type="checkbox" class="dn" id="theme-toggle" onclick="modeSwitcher()" checked />
    <label for="theme-toggle" class="toggle">
    <span class="toggle__handler">
      <span class="crater crater--1"></span>
      <span class="crater crater--2"></span>
      <span class="crater crater--3"></span>
    </span>
        <span class="star star--1"></span>
        <span class="star star--2"></span>
        <span class="star star--3"></span>
        <span class="star star--4"></span>
        <span class="star star--5"></span>
        <span class="star star--6"></span>
    </label>
</div>
<script type="text/javascript">
const theme = localStorage.getItem('theme');

if (theme === "light") {
    document.documentElement.setAttribute('data-theme', 'light');
} else {
    document.documentElement.setAttribute('data-theme', 'dark');
}
const userPrefers = getComputedStyle(document.documentElement).getPropertyValue('content');

function activateDarkTheme() {
    document.getElementById('theme-toggle').checked = true;
    document.documentElement.setAttribute('data-theme', 'dark');
    document.documentElement.classList.add('theme--dark');
    document.documentElement.classList.remove('theme--light');
	document.getElementById("theme-toggle").className = 'light';
	window.localStorage.setItem('theme', 'dark');
}

function activateLightTheme() {
    document.getElementById('theme-toggle').checked = false;
    document.documentElement.setAttribute('data-theme', 'light');
    document.documentElement.classList.add('theme--light');
    document.documentElement.classList.remove('theme--dark');
	document.getElementById("theme-toggle").className = 'dark';
	window.localStorage.setItem('theme', 'light');
}

if (theme === "dark") {
    activateDarkTheme();
} else if (theme === "light") {
    activateLightTheme();
} else if  (userPrefers === "light") {
    activateDarkTheme();
} else {
    activateDarkTheme();
}

function modeSwitcher() {
	let currentMode = document.documentElement.getAttribute('data-theme');
	if (currentMode === "dark") {
	    activateLightTheme();
	} else {
	    activateDarkTheme();
	}
}
</script></div>
  </div>
</footer>


<script>
      window.FontAwesomeConfig = {
        searchPseudoElements: true
      }
    </script>
  </body>

</html>
